# Programming Assignment-2.5

## **Submission 61741567**

## 1. For each of the compilers you are reviewing, choose two programs that run successfully


**Program-1:**

```python
i:int = 4
while i > 0:
    i = i - 1
print(i)
```

The ast that is required for while-statement is mentioned below. Note that, this is not the complete ast.

```javascript
export type Stmt = { tag: "while", expr: Expr, stmts: Array<Stmt>}

export type Expr = { tag: "literal", value: Literal} | { tag: "id", name: string } | { tag: "binop", expr1: Expr, op: Op, expr2: Expr}

export type Op = 
    {tag: "add"}
  | {tag: "sub"}
  | {tag: "mul"}
  | {tag: "div_s"}
  | {tag: "rem_s"}
  | {tag: "eq"}
  | {tag: "ne"}
  | {tag: "le_s"}
  | {tag: "ge_s"}
  | {tag: "lt_s"}
  | {tag: "gt_s"}
  | {tag: "is"}
export type Literal =
    { tag: "None" }
  | { tag: "True", value: boolean, type: Type}
  | { tag: "False", value: boolean, type: Type}
  | { tag: "number", value: number, type: Type}

export type Type =
    { tag: "int" }
  | { tag: "bool" }
```

The parser parses it and adds into the ast of while statement. The relevant snippet of parser is attached below:

```javascript
case "WhileStatement":
      c.firstChild(); // focus on while
      c.nextSibling(); // focus on while cond
      const whileExpr = traverseExpr(c, s);
      c.nextSibling(); // focus on body
      c.firstChild(); // focus on :

      var whileStmts = [];
      while (c.nextSibling()) {
        console.log(traverseStmt(c,s))
        whileStmts.push(traverseStmt(c, s));
      }
      c.parent()  // pop up to body
      c.parent() // pop to while
      return {
        tag: "while",
        expr: whileExpr,
        stmts: whileStmts
      }
```

They implement typechecking as a step in the `codeGenExpr`. The code flow is as follows: `codeGen` -> `codeGenExpr` for condition expression in while -> recursively call `codeGen` for statements inside while.

The `codeGen` code corresponding to while is as follows:

```javascript
case "while":
      var wCond = codeGenExpr(stmt.expr, env);
      var condStmts: string[] = []
      condStmts.push(wCond.join("\n"));
      condStmts.push(`(i64.const ${TRUE}) \n (i64.ne)\n`) // Only necessary when it's actually True false in cond

      var exprStmts: string[] = [];
      //console.log(stmt.stmts);
      stmt.stmts.forEach(st => exprStmts.push(codeGen(st, env).join("\n")));
      //console.log(exprStmts);

      let whileStmts = `(block\n (loop \n ${condStmts.join("\n")} (br_if 1) ${exprStmts.join("\n")} (br 0)) )`
      return [whileStmts]
```
The codeGenExpr performs type checking first and generate code based on expression types. The code for codeGenExpr is as follows:

```javascript
function codeGenExpr(expr: Expr, env: GlobalEnv): Array<string> {
  switch (expr.tag) {
    case "id":
      if (env.globals.has(expr.name)) {
        return [`(i32.const ${envLookup(env, expr.name)})`, `(i64.load)`]
      }
      else {
        return [`(local.get $${expr.name})`] // take cares of parameters and local def
      }
    case "literal":
      const val = expr.value
      switch (val.tag) {
        case "None":
          return [`(i64.const ${NONE})`]
        case "number":
          return ["(i64.const " + val.value + ")"];
        case "False":
          return [`(i64.const ${FALSE})`]
        case "True":
          return [`(i64.const ${TRUE})`]
      }
    // Cases for binary operation and bultin2
    case "binop":
      checkTypeOp(expr.expr1, expr.op, "left side", env)
      checkTypeOp(expr.expr2, expr.op, "right side", env)
      var stmts = codeGenExpr(expr.expr1, env);
      //const stmts2 = codeGenExpr(expr.expr2)
      stmts = stmts.concat(codeGenExpr(expr.expr2, env))
      stmts = stmts.concat(["(i64." + expr.op.tag + ")"])
      // If result is int don't need to signextend
      if (resultIsInt(expr.op)) { return stmts }
      // Sign extend possible boolean result
      return stmts.concat([(`(if (result i64) (then (i64.const ${TRUE})) (else (i64.const ${FALSE})))`)])
    case "uniop":
      //TODO 
      checkTypeOp(expr.expr, expr.uniop, "", env)
      var stmts: string[] = []
      if (expr.uniop.tag === "neg") {
        expr = {
          tag: "binop",
          expr1: { tag: "literal", value: { tag: "number", value: 0, type: { tag: "int" } } },
          expr2: expr.expr,
          op: { tag: "sub" }
        }
        stmts = codeGenExpr(expr, env);
      }
      return stmts
    /*
    var stmts = codeGenExpr(expr.expr, env);
    stmts = stmts.concat(["(i64." + expr.uniop.tag + ")"])
    return stmts.concat(["(i64.extend_i32_s)"])
    */
    case "call":
      var valStmts: string[] = []
      expr.arguments.forEach(arg => valStmts.push(codeGenExpr(arg, env).join("\n")))
      valStmts.push(`(call $${expr.name})`);
      return valStmts
  }
}
```


**Program-2:**

```python
def foo() -> bool:
  return True

foo()
```

The ast that is required for function definition and calling is mentioned below. Note that, this is not the complete ast.

```javascript
export type Parameter = { name: string, type: Type } 

export type Stmt = { tag: "define", name: string, parameters: Array<Parameter>, body: Array<Stmt>, ret: Type}

export type Type =
    { tag: "int" }
  | { tag: "bool" }

export type Expr = { tag: "call", name: string, arguments: Array<Expr> }
```

The parser parses it and adds into the ast of function definition statement and call statement. The relevant snippet of parser is attached below:

```javascript
case "FunctionDefinition":
      c.firstChild();  // Focus on def
      c.nextSibling(); // Focus on name of function
      var funcName = s.substring(c.from, c.to);
      c.nextSibling(); // Focus on ParamList
      var parameters = traverseParameters(c, s);
      c.nextSibling() // focus on body/ret type
      // Has return type
      var retType= null;
      // parse return type
      if(s.substring(c.from,c.to)[0] === '-'){
        c.firstChild();
        retType = traverseType(c, s);
        c.parent();
      }
      c.nextSibling(); // Focus on Body
      c.firstChild();  // Focus on :

      var bodyStmt = []
      // determine if init came first and func declare not inside function
      while (c.nextSibling()) {
        bodyStmt.push(traverseStmt(c, s));
      }
      c.parent();      // Pop to Body
      c.parent();      // Pop to FunctionDefinition
      var ret: Type = { tag: "int" } // todo
      return {
        tag: "define",
        name: funcName, parameters, body:bodyStmt, ret:retType
      }

case "CallExpression":
      c.firstChild();
      const callName = s.substring(c.from, c.to);
      c.nextSibling(); // focus on arglist
      c.firstChild(); //focus on (
      var argList = []
      while(c.nextSibling()){
        if(s.substring(c.from, c.to)===","|| s.substring(c.from, c.to)===")") continue
        var expr = traverseExpr(c, s); 
        argList.push(expr)
      }
      c.parent() // pop arglist
      c.parent() // expressionstmt
      return {tag:"call", name: callName, arguments:argList}
```

The compile function first generates code for functions and then for the rest. They maintain a global flag `isFunc` to indicate whether they are generating code for function or for main.
The compile function is shown below:
```javascript
export function compile(source: string, env: GlobalEnv): CompileResult {
  const ast = parse(source);
  console.log(ast);
  const definedVars = new Set();
  const withDefines = augmentEnv(env, ast);
  // Check if init or func def came before all other
  var cameBefore = true
  var otherAppear = false
  ast.forEach(s => {
    if (s.tag !== "init" && s.tag !== "define") {
      otherAppear = true
    }
    if (otherAppear && (s.tag === "init" || s.tag === "define")) {
      cameBefore = false
    }
  })
  // If not defined before 
  if (!cameBefore) throw new Error("Program should have var_def and func_def at top")

  // Function definition
  const funcs: Array<string> = [];
  ast.forEach((stmt) => {
    if (stmt.tag === "define") { isFunc = true; funcs.push(codeGen(stmt, withDefines).join("\n")); }
  });
  isFunc = false;
  const allFuns = funcs.join("\n\n");
  const stmts = ast.filter((stmt) => stmt.tag !== "define");
  ast.forEach(s => {
    switch (s.tag) {
      case "init":
        definedVars.add(s.name);
        break;
    }
  });
  const scratchVar: string = `(local $$last i64)`;
  const localDefines = [scratchVar];
  definedVars.forEach(v => {
    localDefines.push(`(local $${v} i64)`);
  })

  const commandGroups = stmts.map((stmt) => codeGen(stmt, withDefines).join("\n"));
  const commands = localDefines.concat([].concat.apply([], commandGroups));
  //const commands = commandGroups.join("")
  console.log("Generated: ", commands.join("\n"));
  return {
    declFuncs: allFuns,
    wasmSource: commands.join("\n"),
    newEnv: withDefines
  };
}
```
Let's move on to the code generation of function. The codeGen snippet relevant to code generation for function is shown below:
```javascript
case "define":
      const funcBody = stmt.body
      // Check if init or func def came before all other
      var cameBefore = true
      var otherAppear = false
      funcBody.forEach(s => {
        if (s.tag === "define") { throw new Error("no function declare inside function body") };
        if (s.tag !== "init") {
          otherAppear = true
        }
        if (otherAppear && s.tag === "init") {
          cameBefore = false
        }
      })
      if (!cameBefore) { throw new Error("var_def should preceed all stmts") }

      var params = stmt.parameters.map(p => `(param $${p.name} i64)`).join(" ");
      const funcVarDecls: Array<string> = [];
      //funcVarDecls.push(`(local $$last i64)`);
      // Initialize function var def
      funcBody.forEach(stmt => {
        if (stmt.tag == "init") {
          funcVarDecls.push(`(local $${stmt.name} i64)`);
        }
      });
      // Treat all local 
      // Generate stmts code for func
      var funcStmtsGroup = funcBody.map(stmt => codeGen(stmt, env))
      const funcStmts = [].concat([].concat.apply([], funcStmtsGroup));
      return [`(func $${stmt.name} ${params} (result i64) \n ${funcVarDecls.join("\n")} ${funcStmts.join("\n")})`];
```
It assumes that all variables in a function are local here. But while generating code for `"id"` type expression(code described in the previous problem), it first looks up whether a variable is in global, if yes, it uses global memory to load/store otherwise it uses stack's memory using local.get/set. This leads to a bug here. When there is a function variable with same name as global variable, it would use the value of global variable.

The codeGen code for `init` and `assign` statement checks whether they are generating code for function using `isFunc` variable and based on that they save on stack or global memory. The snippet is shown below:

```javascript
switch (stmt.tag) {
    case "init":
      if (isFunc) {
        var valStmts = codeGenExpr(stmt.value, env)
        valStmts.push(`(local.set $${stmt.name})`)
        return valStmts
      } else {
        const locationToSt = [`(i32.const ${envLookup(env, stmt.name)}) ;; ${stmt.name}`];
        var valStmts = codeGenExpr(stmt.value, env);
        return locationToSt.concat(valStmts).concat([`(i64.store)`]);
      }
    case "assign":
      if (isFunc) {
        var valStmts = codeGenExpr(stmt.value, env);
        // Do type check here
        valStmts.push(`(local.set $${stmt.name})`);
        return valStmts;
      }
      const locationToStore = [`(i32.const ${envLookup(env, stmt.name)}) ;; ${stmt.name}`];
      var valStmts = codeGenExpr(stmt.value, env);
      let tmp = locationToStore.concat(valStmts).concat([`(i64.store)`]);
      console.log(tmp);
      return tmp
```


The codeGenExpr code for call expression is attached above. We can observe that they don't do any typechecking to confirm whether the return type mentioned and actual function return is the same. 


**Bugs, Missing Features, and Design Decisions**

A bug in this submission is it doesn't use function variables when they have same name as global variables and uses global values instead.

I will diagnose this in-detail and suggest the places where the code need to be updated to handle it.

A sample program that doesn't work:

```python
a:int = 6

def foo(a:int) -> int:
  i:int = 4
  i = i + a
  return i

foo(9)
```
The above program returns 10.

To handle this, I would add a `localVars` list/set inside the environment to identify local variables and would update it before generating code for a function. So, my updated environment would look like following:
```javascript
export type GlobalEnv = {
  types: Map<string, string>
  globals: Map<string, number>;
  offset: number;
  localVars: Set<any>;
}
```
Before I generate code for any function, I would update it:
I would create a codeGenFunc that first separates local variables and global variables and populates `localVars` in env and then calls codeGen to generate the code for function body. This is illustrated below as pseudo code below:

```javascript
ast.forEach((stmt) => {
    if (stmt.tag === "define") { 
      isFunc = true; 
      funcs.push(codeGenFunc(stmt, withDefines).join("\n")); 
      }
  });

function codeGenFunc(stmt: Stmt, env: GlobalEnv) : Array<string> {
  // Get the returnStmt
  // Get the params statement 
  // Go through ast: Using init statements, make a list of variables that are initialized inside a function, let's call them definedVars.
  // Generate wasm code for these definedVars: definedVars.forEach(v => {localDefines.push(`(local $${v} i64)`);})
  // Add local defined variables and also function parameters to your localVars inside env.
  // You have to add function parameters as well because they are present on stack and can be fetched and saved using local.get/set the same way as locally defined variables.
  // After populating this env, use this to generate code for functions.
```

Once the localVars is populated and stored in env, I would change the load/store. Basically, I will first check whether it's a function using `isFunc` variable and if it's a function, while loading/storing, I would first check whether it's in the localVars set and if it's present then I would use local.get/set otherwise I would get the memory address from global environment and load/store there. The modified "id" handling would look like following:

```javascript
case "id":
      if (isFunc && isFunctionVar(expr.name, env)) {
        return [`(local.get $${expr.name})`]
      }
      else {
        return [`(i32.const ${envLookup(env, expr.name)})`, `(i64.load)`]
      }
```

where isFunctionVar just checks whether variable is in the `localVars`. 

```javascript
function isFunctionVar(varName: string, env: GlobalEnv) : boolean {
  return env.localVars.has(varName);
}
```

The updated wat code for the above mentioned sample python program would look like:
```javascript
(module
    (func $print (import "imports" "imported_func") (param i64))
    (func $printglobal (import "imports" "print_global_func") (param i64) (param i64))
    (import "js" "memory" (memory 1))
    (func $foo (param $a i64) (result i64) 
      (local $i i64) 
      (i64.const 4)
      (local.set $i)
      (local.get $i)
      (local.get $a)
      (i64.add)
      (local.set $i)
      (local.get $i)
      return
    )
    (func (export "exported_func") (result i64)
      (local $$last i64)
      (local $a i64)
      (i32.const 0) ;; a
      (i64.const 6)
      (i64.store)
      (i64.const 9)
      (call $foo)
      (local.set $$last)
      (local.get $$last)
    )
)
```

**Adding New Features**

I will describe how to add global declarations inside functions for this submission.

The global declarations allow a function to modify a global variable i.e. saving it. Therefore, we need to keep track of global variables inside function that are declared with a `global` keyword. And also, we have to typecheck while saving a global variable in a function whether it is declared with a `global` keyword. Note that, `"init"` statements inside function could be after `global` declarations. So, we need to handle that as well.

Firstly, I would add global statement in 'ast' and would add handle it in parser.

The addition to `ast` will be:

```javascript
export type Stmt = { tag: "global", name: string }
```

Similarly, the parser needs to handle `ScopeStatement` and populate `ast`. We need to modify `traverseStmt` and add an additional handling for `ScopeStatement`.

```javascript
export function traverseStmt(c: TreeCursor, s: string): Stmt {
  .
  .
  .
  case "ScopeStatement":
    //handle it and add to ast for statement
    return {tag: "global", name: variableName}
}
```


Next, I need to keep track of global variables declared with `global` keyword. For this, I would follow the same design as local variables mentioned before. Therefore, I would add a `functionGlobalVars` list/set inside the environment to identify global variables declared inside function and would update it before generating code for a function. So, my updated environment would look like following:
```javascript
export type GlobalEnv = {
  types: Map<string, string>
  globals: Map<string, number>;
  offset: number;
  localVars: Set<any>;
  functionGlobalVars: Set<any>;
}
```
Note that, I am continuing from my previous explanation that keeps track of local variables in a function whose code is generated using `localVars`.

Before I generate code for any function, I would update it by checking whether there are any global variables.
Following the same codeGenFunc mentioned before, I would separate local variables, global declared variables, and global non-declared variables and populate `localVars` in env with local variables and `functionGlobalVars` with global declared variables and then call codeGen to generate the code for function body. This is illustrated below as pseudo code below:

```javascript
ast.forEach((stmt) => {
    if (stmt.tag === "define") { 
      isFunc = true; 
      funcs.push(codeGenFunc(stmt, withDefines).join("\n")); 
      }
  });

function codeGenFunc(stmt: Stmt, env: GlobalEnv) : Array<string> {
  // Check if inits are the first statements other than Global declared statements
  // Get the returnStmt
  // Get the params statement 
  // Go through ast: Using init statements, make a list of variables that are initialized inside a function, let's call them definedVars.
  // Generate wasm code for these definedVars: definedVars.forEach(v => {localDefines.push(`(local $${v} i64)`);})
  // Add local defined variables and also function parameters to your localVars inside env.
  // You have to add function parameters as well because they are present on stack and can be fetched and saved using local.get/set the same way as locally defined variables.
  // Go through ast: Using global statements, make a list of global declared variables, let's call them globalDeclVars.
  // Add globalDeclVars to functionGlobalVars inside env. 
  // After populating this env, use this to generate code for functions.
```

Once the `functionGlobalVars` is populated and stored in env, I would change the store. Basically, I will first check whether it's a function using `isFunc` variable and if it's a function, while storing, I would first check whether it's in the `localVars` set and if it's present then I would use local.get/set, if not I would check whether it's in `functionGlobalVars` and if it's present then I would allow saving and save in global memory  otherwise I would throw an error. The modified "assign" handling where a variable is store, would look like following:

```javascript
case "assign":
      if (isFunc) {
        if (isFunctionVar(expr.name, env)) {
          var valStmts = codeGenExpr(stmt.value, env);
          valStmts.push(`(local.set $${stmt.name})`);
          return valStmts;
        } 
        elif (isFunctionGlobalVar(expr.name, env)) {
          const locationToStore = [`(i32.const ${envLookup(env, stmt.name)}) ;; ${stmt.name}`];
          var valStmts = codeGenExpr(stmt.value, env);
          let tmp = locationToStore.concat(valStmts).concat([`(i64.store)`]);
          console.log(tmp);
          return tmp
        } 
        else {
          throw Error("Saving non-declared global variable is not allowed in a function.")
        }
        
      }
      const locationToStore = [`(i32.const ${envLookup(env, stmt.name)}) ;; ${stmt.name}`];
      var valStmts = codeGenExpr(stmt.value, env);
      let tmp = locationToStore.concat(valStmts).concat([`(i64.store)`]);
      console.log(tmp);
      return tmp
```

where isFunctionVar and isFunctionGlobalVar just checks whether variable is in the `localVars` and `functionGlobalVars` respectively. 

```javascript
function isFunctionVar(varName: string, env: GlobalEnv) : boolean {
  return env.localVars.has(varName);
}

function isFunctionGlobalVars(varName: string, env: GlobalEnv) : boolean {
  return env.functionGlobalVars.has(varName);
}
```

The updated wat code for the following sample python program would look like:
```python
b:int = 6

def foo(a:int) -> int:
  global b
  b = a + b
  return a

foo(9)
```

```javascript
(module
    (func $print (import "imports" "imported_func") (param i64))
    (func $printglobal (import "imports" "print_global_func") (param i64) (param i64))
    (import "js" "memory" (memory 1))
    (func $foo (param $a i64) (result i64) 
    	(i32.const 0) ;; b
		(local.get $a)
		(i32.const 0)
		(i64.load)
		(i64.add)
		(i64.store)
		(local.get $a)
		return
	)
    (func (export "exported_func") (result i64)
    	(local $$last i64)
		(local $b i64)
		(i32.const 0) ;; b
		(i64.const 6)
		(i64.store)
		(i64.const 9)
		(call $foo)
		(local.set $$last)
		(local.get $$last)
  	)
)
```



**A recursive function.**
![Running screenshot of above program](figs/q4_7.png)

